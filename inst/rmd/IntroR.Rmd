---
title: "Introduction to R"
author: "Eva Enns & Zoe Kao"
date: "`r Sys.Date()`"
output:
  html_document:
    number_sections: yes
    toc: yes
    toc_depth: 3
    toc_float: yes
description: Introduction to R for cost-effectiveness analysis
---

# R Basics

This lecture is to introduce the elements in R programming language that are relevant to decision model and decision analysis. 

## Agenda 

* Install R and RStudio
* Data type
* Data input and output
* For loop
* If statement
* R function
* Plots 
* Useful packages in the class 
* Project management

## Install R and RStudio

* You could install R [here](https://repo.miserver.it.umich.edu/cran/). 
  + Be aware of your operating system
  
* The original R interface is not user-friendly. We recommend using the RStudio IDE [here](https://rstudio.com/products/rstudio/download/) 
  + Just download the free version!
  
* Open RStudio 
![](Figure/RStudioIDE.png)

## Data type 

* In this class, we will mainly use `vector`, `matrix`, `array`, `list`, and `data.frame`. 
* These types of data are used intensively in constructing Markov model and in the package of decision analyses

### Vector 

```{r}
x1 <- c(3, 1, 4)
print(x1)

x2 <- c(2, 7, 1)
print(x1 + x2)

future_human <- c("earther", "martian", "belter")
print(future_human)
```

* You could combine different type of vectors
  + This operation coerces the data type into text

```{r}
x1_and_future_human <- c(x1, future_human)
print(x1_and_future_human)
```

* We often create the initial status in the Markov model using vector
  + The distribution of healthy, sick, and dead in a population 
  + You can name the elements in the vector

```{r}
v_init <- c(0.9, 0.09, 0.01)
names(v_init) <- c("healthy", "sick", "dead")
print(v_init)
print(sum(v_init))
```

* Access a specific element in a vector 

```{r}
print(v_init[2])
print(v_init["sick"])
```

### Matrix & Array

* Matrix is defined with two dimension using the numbers of columns and rows

```{r}
x <- matrix(c(1, 0, 0, 
              0.8, 0.2, 0, 
              0, 0, 1), 
            byrow = T, nrow = 3)
print(x)
```

* We often use this as the basis of transition matrix in Markov model or use this to trace the outcomes over time. 
* You could also provide the names to the columns and rows

```{r}
rownames(x) <- colnames(x) <- c("healthy", "sick", "dead")
print(x)
```

* We can access the value of a specific cell

```{r}
print(x[2, 2])
print(x["sick", "sick"])
```

* Matrix multiplication is often used in Markov models. For example, we can multiply the initial state with the transition matrix
  + `v_init` is not a matrix. Thus, we use `t()` to convert `v_init` into a $1 \times 3$ matrix. 
  + `%*%` is the symbol for matrix multiplication in `R`

```{r}
print(t(v_init) %*% x)
```

* If transition probabilities in the transition matrix vary with time, `array()` is more useful. 
* `array()` can be seen as a data type that stores multiple matrices all at once. 
* Let's create two transition matrices and combine them into an array. 

```{r}
tr1 <- x
tr2 <- matrix(c(0.9, 0.1, 0, 
                0.7, 0.2, 0.1, 
                0, 0, 1), 
              byrow = T, nrow = 3, 
              dimnames = list(c("healthy", "sick", "dead"), 
                              c("healthy", "sick", "dead")))
```

* Create an array with dimension $3 \times 3 \times 2$

```{r}
tr_array <- array(dim = c(3, 3, 2), 
                  data = cbind(tr1, tr2), 
                  dimnames = list(c("healthy", "sick", "dead"), 
                              c("healthy", "sick", "dead"), 
                              c(1, 2)))
print(tr_array)
```

* We can access each transition matrix by proper indexing 

```{r}
print(tr_array[ , ,  1])
print(tr_array[ , ,  2])
```

* We can also access a specific value of the transition array

```{r}
print(tr_array[1, 2, 1])
```

* Similarly, we can perform calculation using a slice of array

```{r}
v_time2 <- t(v_init) %*% tr_array[ , , 1]
print(v_time2)

v_time3 <- v_time2 %*% tr_array[ , , 2]
print(v_time3)
```

### List 

* List can combine different types of data without affecting the data type. 

```{r}
temp_ls <- list(future_human = future_human, v_init = v_init, tr_array = tr_array)
print(temp_ls)
```

* There are two approaches to access an element in the list 

```{r}
print(temp_ls[[1]])
print(temp_ls$v_init)
```

* You can access a specific element in an element of a list
```{r}
print(temp_ls$tr_array[, , 1])
```

### `data.frame`

* If your Stats or Biostats classes use `R`, you probably have encountered `data.frame()` very frequently.
* Let's create a `data.frame()`

```{r}
profile <- data.frame(name = c("Amos", "Bobbie", "Naomi"), 
                      human_type = c("earther", "martian", "belter"), 
                      height = c(1.8, 2.1, 1.78))
print(profile)
```

* `data.frame()` is essentially a named list of vectors with the same length. 

```{r}
typeof(profile)
length(profile$name) 
length(profile$human_type)
length(profile$height)
```

## Data input and output

* If you have external datasets, you could load or read in the datasets. 
* The data extension of the external datasets could be `.RData`, `.rda`, `.rds`, `.csv`, `.txt`, etc. There are multiple ways to load, read, save, or write different types of data. You could find the information [here](https://bookdown.org/lyzhang10/lzhang_r_tips_book/how-to-read-data-into-r.html) and [here](https://mgimond.github.io/ES218/Week02b.html). 

## For loop 

* 

## If statement

## R function

## Plots

## Useful packages in the class 

## Project management



# Decision tree

## Agenda 

* Introduction of Amua
* Creating a decision tree using Amua
* Example
* Exporting Amua decision tree to R script
* Prepare the R decision tree from Amua for further analyses

For a simple decision tree, we can draw the tree easily. As the decision tree grows, there is software helping you draw the tree such as TreeAge and Amua. In this class, we use [Amua](https://github.com/zward/Amua) because it is free. We will show how to use Amua to build a decision tree and export the tree to R script for CEA analysis. 

## Install Amua

Follow the instruction [here](https://github.com/zward/Amua/wiki/Getting-Started) to install Amua. Be aware of the difference between Mac and Windows users! After you install Amua, remember where you store the software. 

## Create a decision tree 

### Open the `Amua.jar`. 

![](Figure/Amua_open.png)

### Decision, chance, terminal nodes, and decision tree

<video width="600" height="400" controls>
  <source src="Figure/Amua_basics1.mp4" type="video/mp4">
</video>

### Parameterization

<video width="600" height="400" controls>
  <source src="Figure/Amua_basics2.mp4" type="video/mp4">
</video>


### Adding more outcomes

<video width="600" height="400" controls>
  <source src="Figure/Amua_basics3.mp4" type="video/mp4">
</video>

### Change analysis

<video width="600" height="400" controls>
  <source src="Figure/Amua_basics4.mp4" type="video/mp4">
</video>

### Save the model and export the tree to R code

<video width="600" height="400" controls>
  <source src="Figure/Amua_basics5.mp4" type="video/mp4">
</video>

* Notice that Amua created a folder, called `temp_Export/`. 
* In this folder, there are two `.R` files: `main.R` and `functions.R`. 
* The body of the decision tree model is in `main.R`. 

## Example

Dracula is preparing for a spring break party tonight. But there’s one final decision that Dracula is struggling with. Being a vampire, he intends to bite and suck the blood of some of his guests at the party (about 25% of them, by his best estimate). While being bitten by a vampire won’t turn his guests into vampires or zombies, like some horror movies might suggest, there is a 50% chance that a vampire bite results in a rather severe bacterial infection, of which 66% of cases require hospitalization for an average of 1 night.

Being a gracious host, Dracula is considering different ways of administering antibiotic prophylaxis to his guests to reduce their risk of infection. One option is to administer the antibiotics to his victim‐guests just before he bites them – this would reduce the risk of a vampire bite infection by 20%. However, the antibiotics can be even more effective, reducing the risk of infection by 90%, if administered at least 30 minutes before being bitten. To achieve this, Dracula is considering putting the antibiotics into the drinks served at the party to ensure that his guests are all properly dosed before he bites his victims. But this means that all his guests would be exposed to the antibiotics (not just those he intends to bite), and he knows that about 5% of people are severely allergic to these antibiotics and would require immediate hospitalization if exposed. Dracula is therefore also considering not administering antibiotic prophylaxis at all to avoid this harm.

However, all the healthy blood doesn't come without cost. This party will cost Dracula \$1000 for a total of 200 guests (an average of \$5 per guest). In addition, Dracula expects the cost of antibiotic to be \$10 for each guest he bites. If Dracula decides to administer the antibiotics in all the drinks served at the party, the total cost of antibioitics is expected to be $100 (Dracula gets discount for buying a large batch of antibiotics!). Also, Dracula is willing to pay for the cost of hospitalization for any guest who experience bacteiral infection due to his bites because he feels responsible. The cost of hospitalization per person per night is \$500. Dracula expects to get an average of 470 mL healthy blood by biting a guest. However, if the guest ends up hospitalized due to bacterial infection, the healthy blood that Dracula can get is reduced by 10%. 

Dracula hopes you can help him determine which strategy he should choose.

You can build a decision tree via Amua. 

![](Figure/DraculaTree.png)


## Wrapper function for decision tree exported from Amua

* The decision tree created in Amua can be exported to R. 
* However, the R script created by Amua is not easy to use for advance CEA analysis (e.g., PSA, one/two-way sensitivity analysis, EVPI, etc.). 
* We created some wrapper functions to reshape the R script from Amua. This transformation of code allows us to do further analysis using other packages in R. 
* Install the package using the following code. 

```{r message = FALSE, warnings = FALSE}

if(!require("remotes")) install.packages("remotes")
if(!require("CEAutil")) remotes::install_github("syzoekao/CEAutil", dependencies = TRUE)

library(CEAutil)
```

* We will use two functions from the package to convert the R script exported from Amua. 
1. `parse_amua_tree()`: 

This function only takes an input argument, the path to the `main.R` file of the Amua decision model. The function returns a list of outputs. Output 1 `param_ls` is a list of input parameters with basecase values used in Amua. Output 2 `treefunc` is the R code of the Amua decision model formatted as text. 


```{r class.source = 'fold-show'}
treetxt <- parse_amua_tree("AmuaExample/DraculaParty_Export/main.R")

print(treetxt$param_ls)
```

2. `dectree_wrapper()`: 

We use the two outputs from the `parse_amua_tree()` as the input arguments in the `dectree_wrapper()`. The input arguments in the wrapper function include `params_basecase`, `treefunc`, and `popsize`. `params_basecase` takes a list of named input parameters. `treefunc` takes the text file organized by the `parse_amua_tree()`. `popsize` is defaulted as 1 but you could change your population size. 

```{r class.source = 'fold-show'}
param_ls <- treetxt[["param_ls"]]
treefunc <- treetxt[["treefunc"]]

tree_output <- dectree_wrapper(params_basecase = param_ls, treefunc = treefunc, popsize = 200)
```

* The cost and effectiveness of each of Dracula's strategy based on the basecase values

```{r}
print(tree_output)
```

## Change parameter values

* Many of the parameters are organized as a variable in the decision tree. We can easily see how the cost and effectiveness vary with changes of parameters of interest.

**Example 1.** Dracula has been starved over the long cruel winter in Minnesota. The Spring break is the first time that his guests are willing to come to his party in several months. Therefore, Dracula is going to seize the chance to bite as many guests as possible. The probability that he bites a guest is now increased to 50%. What are the cost and effectiveness of each strategy? 

```{r}
param_ls$p_bite <- 0.5

tree_output <- dectree_wrapper(params_basecase = param_ls, treefunc = treefunc, popsize = 200)

print(tree_output)
```


**Example 2.** The cost of hospitalization due to bacterial infection varies from guest to guest depending on the healthcare that a guest has. Overall, the cost of hospitalization has a mean of \$500 with a standard deviation \$300 following a gamma distribution. What are the mean cost and effectiveness of the party across all 200 guests? 

```{r message = FALSE, warning = FALSE}
if(!require(dampack)) remotes::install_github("DARTH-git/dampack", dependencies = TRUE)

require(dampack)

C_hospital <- gen_psa_samp(params = c("C_hospital"), 
                           dists = c("gamma"), 
                           parameterization_types = c("mean, sd"), 
                           dists_params = list(c(500, 250)), 
                           nsamp = 200)

cat("mean and sd are", c(mean(C_hospital$C_hospital), sd(C_hospital$C_hospital)), ", respectively.")

hist(C_hospital$C_hospital, main = "histogram", xlab = "values", ylab = "frequency")

tree_vary <- dectree_wrapper(params_basecase = param_ls, 
                       treefunc = treefunc, 
                       popsize = 1, 
                       vary_param_samp = C_hospital)
```

* The elements in the tree_vary output

```{r}
print(names(tree_vary))
```

* Let's take a look at some elements in the tree_vary output

```{r}
print(head(tree_vary$param_samp))
print(head(tree_vary$expectedEff1))
print(head(tree_vary$expectedCost))
```

* The mean cost 

```{r}
print(summary(tree_vary$expectedCost))
```

# Markov model

## Agenda

* General Markov model coding structure
* Follow the coding steps using an example
* The template of Markov model function 
* Consideration of strategies 
* Prepare your Markov model for further analyses

## General Markov model coding structure

* We will show how to code a Markov model step by step. 
* In general, we follow this structure: 

```{}
markov_model <- function(l_param_all,
                         strategy = NULL) {
  #### 1. Read in, define, or transform parameters if needed
  
  #### 2. Create the transition probability matrices using array
  
  #### 3. Create the trace matrix to track the changes in the population distribution 
  #### through time. You could also create other matrix to track different outcomes,
  #### e.g., costs, incidence, etc.
  
  #### 4. Get outputs
  
  #### 5. Return the relevant results
}
```

* Then we write this process into a function `markov_model()`

## Example 

The Canadian province of Ontario is considering a province-wide ban on indoor tanning as a means of preventing skin cancer, with a focus on young women. The Ontario Ministry of Health has just finished a large observational study on tanning behaviors and skin cancer incidence among women in Ontario to inform their decision.

In their surveillance study, they found that skin cancer risks differ substantially for individuals who visit tanning salons regularly (“regular tanners”) and those who do not ("non-tanners"). The annual risk of skin cancer was 4% for regular tanners vs. 0.5% for non-tanners. (Assume that skin cancer risk depends only on current tanning behavior and not on tanning history).

The Ministry of Health also studied tanning behaviors. They estimated the annual probability of a non-tanner becoming a regular tanner, by age, among women. This probability begins increasing around age 12, peaks at age 24 and then begins to decrease. They also estimated the rate of a regular tanner becoming a non-tanner. This probability is low until age 30, after which it increases with age. These data are summarized in the dataset `ONtan` in the `CEAutil` package.

Skin cancer resolves within one year of diagnosis, with 7% of cases resulting in death. Those who recover following a skin cancer diagnosis nearly all quit tanning, though they re-initiate indoor tanning at the same rate as their peers who have not experienced skin cancer.

The Ontario Ministry of Health is considering an indoor tanning ban for those 18 years of age and younger (reducing the rate of tanning initiation to zero among this age group). They are also considering a full indoor tanning ban, which would reduce the rate of tanning initiation to zero for everyone in Ontario. They would like to evaluate the impact that each of these policies would have over the lifetime of a cohort of 10-year-old girls. The Ministry of Health does not wish to discount outcomes.

1. Draw a Markov model diagram of tanning behavior and skin cancer that the Ontario Ministry of Health could use to evaluate their tanning policies in terms of the desired outcomes. Use a yearly time step. Include the following states: "Non-tanners", "Regular tanners", "Skin cancer", "Dead from skin cancer", and "Dead from other causes". Label all transition probabilities and indicate which are changing over time.

2. Calcuate the remaining life-expectancy of a 10-year-old girl under each strategy.

### Step 0. Model setup 

Before doing any actual coding: 

1. Draw your Markov model diagram
2. Figure out your parameters 
  + which are fixed? 
  + which are time varying? 
  + do you have parameters that require calibration? 

3. What is the time horizon? 
  + 100 years

4. What is the cycle length? 
  + annual time step

Here is the Markov model diagram: 

![](Figure/skin cancer.png)

### Step 1. Set up parameters, data, and variables required

* We start with setting up parameter values, function, or transformation. 
* The parameters included in this example: 

```{r, echo = FALSE, message = FALSE, warning = FALSE}
library(kableExtra)

input_table <- data.frame("parameter code" = c("p_init_tan", "p_halt_tan", "p_nontan_to_cancer", "p_regtan_to_cancer", "p_cancer_to_dead", "p_mort"), 
                          "definition" = c("probability of initiating tanning", "probability of discontinuing tanning", "probability of having skin cancer among non-tanners", "probability of having skin cancer among regular tanners", "probability of cancer-specific death", "probability of natural death"), 
                          "data type" = c("table", "table", "constant", "constant", "constant", "table"))

kable(input_table, col.names=c("parameter code", "definition", "data type")) %>% 
  kable_styling(full_width = F, position = "center") 
```

* You could find the tanning behavior and the life table in the `CEAutil` package. 

```{r}
library(CEAutil)

data(ONtan)
ltable <- ONtan$lifetable
behavior <- ONtan$behavior

print(head(ltable))
print(head(behavior))
```

* For the constant parameters: 

```{r}
p_nontan_to_cancer <- 0.005
p_regtan_to_cancer <- 0.04
p_cancer_to_dead <- 0.07
```

* In addition, we have other required variables 
  + timehorizon (`n_t`)
  + names of each health state (`state_names`)
  + initial status (`v_init`)

```{r}
n_t <- 100 
state_names <- c("nontan", "regtan", "cancer", "deadnature", "deadcancer")
v_init <- c(1, 0, 0, 0, 0)
```

* These input parameters are often defined **outside** the `markov_model()` function. In this model framework, we use `list()` to combine all the parameters, data, and variables defined beforehand. We provide the name for each the element in the list. 

```{r}
l_param_all <- list(p_nontan_to_cancer = 0.005,
                    p_regtan_to_cancer = 0.04,
                    p_cancer_to_dead = 0.07, 
                    ltable = ltable,
                    behavior = behavior, 
                    state_names = c("nontan", "regtan", "cancer", "deadnature", "deadcancer"),
                    n_t = 100,
                    v_init = c(1, 0, 0, 0, 0))
```

* In the function, we start with some basic calculation and transformation of the input parameters, data, and variables that will be used in the Markov model. 

```{r, eval = FALSE}
#### 1. Read in, set, or transform parameters if needed
# We need the age index for matching values of the lifetable and behavior data.
ages <- c(10 : (10 + n_t - 1))

# We extract the probability of natural death age 10-110 from the lifetable. 
p_mort <- ltable$qx[match(ages, ltable$age)]

# We modify the values of tanning behavior based on strategy of interest.
if (strategy == "targeted ban") {
  behavior$p_init_tanning[behavior$age <= 18] <- 0
}
if (strategy == "universal ban") {
  behavior$p_init_tanning <- 0
}

# We extract the tanning behavior at age 10-110 from the behavior data 
p_init_tan <- behavior$p_init_tanning[match(ages, behavior$age)]
p_halt_tan <- behavior$p_halt_tanning[match(ages, behavior$age)]

# We get the number of health states based on the length of the string vector, state_names
n_states <- length(state_names)
```

```{r, echo = FALSE, message = FALSE, warning = FALSE}
ages <- c(10 : (10 + n_t - 1))

# We extract the probability of natural death age 10-110 from the lifetable. 
p_mort <- ltable$qx[match(ages, ltable$age)]

# # We modify the values of tanning behavior based on strategy of interest.
# if (strategy == "targeted ban") {
#   behavior$p_init_tanning[behavior$age <= 18] <- 0
# }
# if (strategy == "universal ban") {
#   behavior$p_init_tanning <- 0
# }

# We extract the tanning behavior at age 10-110 from the behavior data 
p_init_tan <- behavior$p_init_tanning[match(ages, behavior$age)]
p_halt_tan <- behavior$p_halt_tanning[match(ages, behavior$age)]

# We get the number of health states based on the length of the string vector, state_names
n_states <- length(state_names)
```

### Step 2. Create the transition probability array 

* A transition probability matrix contains the transition probability from one health state to another state. 

```{r, echo = FALSE}
transit_matrix <- matrix(c(0.1, 0.2, 0.7, 
                           0.5, 0.1, 0.4, 
                           0.7, 0, 0.3), byrow = T, ncol = 3, 
                         dimnames = list(c("state1", "state2", "state3"), 
                                         c("state1", "state2", "state3")))
print(transit_matrix)
```

* In many of our applications, individuals transit from the row state to the column state. Each row should sum up to 1. 

```{r}
print(rowSums(transit_matrix))
```

* The transition probability array can contain more than one transition matrix. Because the behavior and mortality vary over time. The transition matrix is different from year to year. Thus, we create a transition array with the following dimension $n\_state \times n\_state \times n\_t$. 

```{r}
tr_mat <- array(0, dim = c(n_states, n_states, n_t),
                dimnames = list(state_names, state_names, ages))
```

* We initiate the transition array with 0 because most transition probabilities are zeros. 
* Then we modify the transition probabilities for each origin state. 

```{r}
# 1. Fill out the transition probabilities from non-tanner to other states
tr_mat["nontan", "regtan", ] <- p_init_tan
tr_mat["nontan", "cancer", ] <- p_nontan_to_cancer
tr_mat["nontan", "deadnature", ] <- p_mort
tr_mat["nontan", "nontan", ] <- 1 - p_init_tan - p_nontan_to_cancer - p_mort

# 2. Fill out the transition probabilities from regular tanner to other states
tr_mat["regtan", "nontan", ] <- p_halt_tan
tr_mat["regtan", "cancer", ] <- p_regtan_to_cancer
tr_mat["regtan", "deadnature", ] <- p_mort
tr_mat["regtan", "regtan", ] <- 1 - p_halt_tan - p_regtan_to_cancer - p_mort

# 3. Fill out the transition probabilities from skin cancer to other states.
#    Be careful that this is a tunnel state. Therefore, there is no self loop.
tr_mat["cancer", "deadcancer", ] <- p_cancer_to_dead
tr_mat["cancer", "deadnature", ] <- p_mort
tr_mat["cancer", "nontan", ] <- 1 - p_cancer_to_dead - p_mort

# 4. Fill out the transition probabilities for cancer specific death (this is an absorbing state!!)
tr_mat["deadcancer", "deadcancer", ] <- 1

# 5. Fill out the transition probabilities for natural death (this is an absorbing state!!)
tr_mat["deadnature", "deadnature", ] <- 1
```

* Let's see two slice of the transition array

```{r}
print(tr_mat[, , "20"])
```

```{r}
print(tr_mat[, , "50"])
```

* Check whether the transition array meets the criteria of transition matrix

```{r}
# Check whether the transition matrices have any negative values or values > 1!!!
if (sum(tr_mat > 1) | sum(tr_mat < 0)) stop("there are invalid transition probabilities")

# Check whether each row of a transition matrix sum up to 1!!!
if (any(rowSums(t(apply(tr_mat, 3, rowSums))) != n_states)) stop("transition probabilities do not sum up to one")
```

### Step 3. Create the trace matrix and outcome matrix 

* Initialize the trace matrix and replace the first row with the initial state (`v_init`)

```{r}
#### 3. Create the trace matrix to track the changes in the population distribution through time
#### You could also create other matrix to track different outcomes,
#### e.g., costs, incidence, etc.
trace_mat <- matrix(0, ncol = n_states, nrow = n_t + 1,
                    dimnames = list(c(10 : (10 + n_t)), state_names))
# Modify the first row of the trace_mat using the v_init
trace_mat[1, ] <- v_init
```

* If you are interested in tracking other outcomes, initialize an empty matrix here. 

```{r}
# Suppose that we want to track the cost of having skin cancer for a year
trace_cost <- rep(0, n_t)
```

### Step 4. Compute the Markov model over time

* We use `for()` loop to iterate the calculation through time. 

```{r}
#### 4. Compute the Markov model over time by iterating through time steps
for(t in 1 : n_t){
  trace_mat[t + 1, ] <- trace_mat[t, ] %*% tr_mat[, , t]
}
```

### Step 5. Organize outputs

* The outcome in this example is "expected life years" (`LE`). Therefore, we remove the last two columns.
  + Calculate the sums by each row for the remaining columns. 
  + Calculate the life expectancy by summing up all the values. 

* We organize the output in a `data.frame` with the strategy in the first column and `LE` as the second column. 
* You could add more columns to the `data.frame` if you have more outcomes of interest (e.g., cost) 

```{r}
#### 5. Organize outputs
LE <- sum(rowSums(trace_mat[, -c(4, 5)])) - 1
output <- data.frame("strategy" = "null",
                     "LE" = LE)
```

### Step 6. Return the relevant outputs

* Finally, return the outputs/results from the function. 

```{r, eval = FALSE}
return(output)
```

* You could return a list of outputs. For example, if you want to also return the trace matrix, you could do this: 

```{r, eval = FALSE}
return(list(output = output, trace = trace_mat))
```

## The template Markov model function

* You could find the template Markov model function in the `CEAutil` package. 
* You can modify the function for your project. 

`r text_spec("Need discussion!! Should we illustrate how to calculate cost?", background = "#D05A6E", color = "white", bold = T)`

```{r}
library(CEAutil)

print(markov_model)
```

## Strategies 

* Notice that the `markov_model()` function has another argument `strategy`. 
* Specifying different strategy produces different life expectancy. 
* In our example, there are three types of strategies: "null", "targeted ban", "universal ban". The default value is NULL, which means null strategy. 

```{r}
print(markov_model(l_param_all = l_param_all, strategy = "null"))
print(markov_model(l_param_all = l_param_all, strategy = "targeted ban"))
print(markov_model(l_param_all = l_param_all, strategy = "universal ban"))
```

* In our example, the strategy is modifying the probability of initiating tanning. Therefore, we program the effect of strategy at step 1. 
* However, strategies are sometimes more complicated to capture. The influence of different strategy might occur in step 2 and step 4 (if the calculation of transition probability at step *t* depends on the state of step *t* - 1). 

## Markov model wrapper function

* Calculating the results for each strategy one by one is easy for one set of parameters but might become more and more tedious when the scope of the job is growing.  
* `markov_decision_wrapper()` is to calculate the results of all strategies all at once. 
  + `vary_param_ls`: the parameters that could change in other more advance analyses
  + `other_input_ls`: the paramters, datasets, and variables that do not change from simulation to simulation
  + `userfun`: the Markov model function. You could also create your own Markov model function 
  + `strategy_set`: The vector of the strategy names.  

```{r}
vary_param_ls <- list(p_nontan_to_cancer = 0.005,
                      p_regtan_to_cancer = 0.04,
                      p_cancer_to_dead = 0.07)

other_input_ls <- list(ltable = ltable,
                       behavior = behavior,
                       state_names = c("nontan", "regtan", "cancer", "deadnature", "deadcancer"),
                       n_t = 100,
                       v_init = c(1, 0, 0, 0, 0))
res <- markov_decision_wrapper(vary_param_ls = vary_param_ls,
                               other_input_ls = other_input_ls,
                               userfun = markov_model,
                               strategy_set = c("null", "targeted ban", "universal ban"))
print(res)
```

* We can change the values in the `l_param_all` easily. 

```{r}
vary_param_ls <- list(p_nontan_to_cancer = 0.005,
                      p_regtan_to_cancer = 0.08,
                      p_cancer_to_dead = 0.1)

res <- markov_decision_wrapper(vary_param_ls = vary_param_ls,
                               other_input_ls = other_input_ls,
                               userfun = markov_model,
                               strategy_set = c("null", "targeted ban", "universal ban"))
print(res)
```


# dampack

## Agenda

* General introduction of `dampack`
* One-way sensitivity analysis
* Two-way sensitivity analysis
* Probabilistic sensitivity analysis
* Dampack and markov model wrapper 

## Introduction of `dampack`

* `dampack` is the decision analysis modeling package [here](https://github.com/DARTH-git/dampack). 
* We have used some functionality in the past.  
* This package includes functionalities for basic and advanced decision analysis. 
* We will illustrate deterministic analysis and probabilistic analysis using the Dracula example and also show how to use dampack with the Markov model wrapper. 

```{r message = FALSE, warning = FALSE}
library(CEAutil)
library(dampack)
```

## One-way sensitivity analysis

* Investigate the changes in the outcomes by varying one parameter at a time. 
* Dracula is interested in how the cost and effectiveness change with probabililty of biting a guest (`p_bite`), the cost of the antibiotics (`C_drug`), and the probability of infection after he bites a guest (`p_inf_bitten`), respectively
* `run_owsa_det()` is for the one-way sensitivity analysis. Let's take a look into the `run_owsa_det()` function: 

```{r, eval = FALSE}
run_owsa_det(params_range, params_basecase, nsamp = 100, FUN, 
             outcomes = NULL, strategies = NULL, ...)
```

  + `params_range`: a `data.frame` with 3 columns in the following order: "pars", "min", and "max". 
  
```{r}
params_range <- data.frame(pars = c("p_bite", "C_drug", "p_inf_bitten"), 
                           min = c(0.05, 2, 0.2), 
                           max = c(0.8, 20, 0.9))
print(params_range)
```

  + `params_basecase`: a named list of basecase values for input parameters needed by the user-defined decision function `FUN`.
  
```{r}
treetxt <- parse_amua_tree("AmuaExample/DraculaParty_Export/main.R")
treefunc <- treetxt[["treefunc"]] # This is the tree function text from Amua
param_ls <- treetxt[["param_ls"]] # This is a list of parameters with basecase values
print(param_ls)
```

  + `nsamp`: number of samples. Default is 100. 

  + `FUN`: user-defined function that takes the basecase in `params_basecase` and `...` to produce the outcome(s) of interest. The `FUN` must return a dataframe where the first column are the strategy names and the rest of the columns must be outcomes. The function used in our tree example is `dectree_wrapper()`. 

  + `outcomes`: The outcomes of interest. If you use the default setting `NULL`, `run_owsa_det` will run the one-way sensitivity analysis for every outcome. In our case, the outcomes include expectedEff1, expectedEff2, and Cost. You could also specify a subset of outcomes: 

```{r}
outcomes = c("expectedEff1", "Cost")
```
  
  + `strategies`: You can leave this as default or give your favorite names to the strategies. 

  + `...`: Additional arguments for the user-defined function `FUN`. In our case, `dectree_wrapper()` requires `params_basecase`, `treefunc`, and `popsize`. We have already set up the `params_basecase`. Thus, for `...`, we need to add `treefunc` and `popsize`. 

```{r}
owsa_out <- run_owsa_det(params_range, param_ls, nsamp = 100, 
                         dectree_wrapper, 
                         treefunc = treefunc, popsize = 200)
print(str(owsa_out))
print(head(owsa_out$owsa_Cost))
```

* We can see how each parameter affects the cost and effectiveness. 

```{r}
plot(owsa_out$owsa_expectedEff1)
plot(owsa_out$owsa_Cost)
```


## Two-way sensitivity analysis

* Investigate the changes in the outcomes by varying two parameters simultaneously. 
* Dracula wants to know how the cost and effectiveness changes as `p_bite` and `C_drug` both changes. 
* `run_twsa_det()` allows us to investigate two-way sensitivity analysis for any pair of parameters. 

```{r, eval = FALSE}
run_twsa_det(params_range, params_basecase, nsamp = 40,
  FUN, outcomes = NULL, strategies = NULL, ...)
```

* The structure of the function is very similar to `run_owsa_det()`. The primary difference is the function can only take two parameters at a time in the `params_range`. 

```{r}
params_range <- data.frame(pars = c("p_bite", "C_drug"), 
                           min = c(0.05, 2), 
                           max = c(0.8, 20))
```

* Run the two-way sensitivity analysis and see the two-way plots. 

```{r}
twsa_out <- run_twsa_det(params_range, param_ls, nsamp = 10, 
                         dectree_wrapper, 
                         treefunc = treefunc, popsize = 200)
plot(twsa_out$twsa_expectedEff1)
plot(twsa_out$twsa_Cost)
```

## Probabilistic sensitivity analysis

`r text_spec("Need discussion!!", background = "#D05A6E", color = "white", bold = T)`

### Generate your PSA samples

* `gen_psa_samp()`

### Conduct PSA

* `run_psa`

## Conducting decision analysis using Markov model

```{r warning = FALSE}
library(CEAutil)
library(data.table)
library(dampack)
data(ONtan)
ltable <- ONtan$lifetable
behavior <- ONtan$behavior

vary_param_ls <- list(p_nontan_to_cancer = 0.005,
                      p_regtan_to_cancer = 0.04,
                      p_cancer_to_dead = 0.07)

other_input_ls <- list(ltable = ltable, 
                       behavior = behavior, 
                       state_names = c("nontan", "regtan", "cancer", "deadnature", "deadcancer"),
                       n_t = 100,
                       v_init = c(1, 0, 0, 0, 0))

res <- markov_decision_wrapper(vary_param_ls = vary_param_ls, 
                        other_input_ls = other_input_ls, 
                        userfun = markov_model, 
                        strategy_set = c("null", "targeted ban", "universal ban"))

params_range <- data.frame(pars = c("p_regtan_to_cancer", "p_cancer_to_dead"), 
                           min = c(0.01, 0.01), 
                           max = c(0.1, 0.1))

owsa_out <- run_owsa_det(params_range, vary_param_ls, nsamp = 100, 
                         FUN = markov_decision_wrapper, 
                         userfun = markov_model, 
                         other_input_ls = other_input_ls, 
                         strategy_set = c("null", "targeted ban", "universal ban"))
plot(owsa_out)

twsa_out <- run_twsa_det(params_range, vary_param_ls, nsamp = 10, 
                         FUN = markov_decision_wrapper, 
                         userfun = markov_model, 
                         other_input_ls = other_input_ls, 
                         strategy_set = c("null", "targeted ban", "universal ban"))
plot(twsa_out)
```



